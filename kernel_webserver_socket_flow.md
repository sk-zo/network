# 커널과 웹서버 간 데이터 전달 구조 정리

## 📌 개요

웹 요청이 클라이언트에서 서버로 전달될 때, 그 데이터는 **바이너리 바이트 스트림**으로 전송됩니다.  
커널은 이 데이터를 처리해 웹서버에 전달하며, 웹서버는 이 데이터를 문자열로 해석하고 파싱합니다.  
또한, 이 모든 흐름은 **소켓(socket)**이라는 인터페이스를 통해 이루어집니다.

---

## 1. 데이터 흐름 요약

```
[클라이언트]
     ↓ (ASCII 문자열 → 바이너리 인코딩)
[TCP/IP 계층을 통한 전송]
     ↓
[서버 커널 - TCP/IP 헤더 제거]
     ↓
[Socket Buffer (Payload 저장)]
     ↓
[웹서버 애플리케이션 - Payload 문자열로 디코딩 및 파싱]
```

---

## 2. 바이너리란?

- 바이너리(binary) 데이터란 사람이 읽기 어려운 **0과 1로 구성된 데이터 형식**입니다.
- 컴퓨터는 모든 파일을 결국 이진수로 저장하고 해석합니다.
- 바이너리 파일은 보통 사람이 읽지 못하도록 구조화되어 있고, **특정 포맷 규칙**을 가집니다.

### 📎 예시
- `.txt`, `.html` → 사람이 읽을 수 있는 ASCII/UTF-8 인코딩
- `.jpg`, `.exe`, `.zip` → 구조화된 이진 데이터 → 바이너리 파일

---

## 3. TCP 패킷과 웹서버 데이터

### ▶ TCP 패킷 구조
```
[Ethernet Header][IP Header][TCP Header][Payload (예: HTTP 요청)]
```

- Payload는 실제 HTTP 요청 데이터가 ASCII 인코딩된 바이트 스트림입니다.

### ▶ 커널의 역할
- TCP/IP 헤더를 제거하고, Payload만 socket buffer에 저장
- 웹서버는 이 buffer에서 데이터를 읽음

---

## 4. 소켓(Socket)이란?

- 소켓은 네트워크 통신을 위한 **커널과 애플리케이션 간의 인터페이스**입니다.
- 클라이언트와 서버가 데이터를 주고받을 때, 각자 **소켓을 통해 통신**합니다.
- 소켓은 TCP 연결을 통해 데이터의 송수신을 가능하게 합니다.

### ▶ 서버 측 소켓 처리 흐름 (C/PHP 등 공통)

1. `socket()` – 소켓 생성  
2. `bind()` – 포트에 소켓 바인딩  
3. `listen()` – 연결 대기  
4. `accept()` – 클라이언트 연결 수락  
5. `recv()` / `read()` – 데이터 수신 (Payload)

---

## 5. 웹서버에서 데이터 처리

- 웹서버는 소켓을 통해 받은 데이터를 ASCII 문자열로 디코딩
- 이후 HTTP 프로토콜 규칙에 따라 파싱

```http
GET /index.html HTTP/1.1

Host: example.com

User-Agent: curl/7.68.0



```

---

## 6. 요약 비교

| 단계 | 데이터 형태 | 설명 |
|------|--------------|------|
| 클라이언트 → 서버 | ASCII 문자열 → 바이너리 바이트 스트림 | 전송 전 ASCII 인코딩 |
| TCP 계층 | TCP 헤더 + Payload | Payload에 HTTP 요청 포함 |
| 커널 | TCP/IP 헤더 제거 후 Payload 전달 | socket buffer에 저장 |
| 웹서버 | Payload를 문자열로 디코딩 후 파싱 | GET, Host 등 분석 |

---

## ✅ 결론

- 클라이언트는 HTTP 요청을 ASCII 문자열로 작성하여 바이트 스트림으로 전송합니다.
- 커널은 TCP 헤더를 제거하고 Payload만 웹서버에 전달합니다.
- 웹서버는 이 데이터를 문자열로 디코딩하고 파싱하여 처리합니다.
- 이 모든 과정은 **소켓(socket)**을 통해 연결되고 동작합니다.

---

## 7. 포트와 소켓의 역할 구분 상세 분석

### 📌 핵심 이해

> **포트**: 외부에서 프로세스를 식별하기 위한 "주소" 역할  
> **소켓**: 실제 데이터가 전달되는 "통신 통로" 역할

포트의 역할은 **요청의 도착 프로세스를 식별하는 것에서 끝나고**, 실제 데이터는 **해당 프로세스의 소켓을 통해 전달**됩니다.

### 🔍 상세한 데이터 통신 과정

#### **1단계: 포트의 역할 (라우팅 단계)**
```
패킷 도착 → 커널이 TCP 헤더의 "목적지 포트" 확인 → 해당 포트를 사용하는 프로세스 찾기
```

**실제 TCP 헤더에서:**
```
[IP Header][TCP Header: src_port=12345, dst_port=65432][HTTP Data]
                        ↑
                   커널이 이 부분을 보고 
                 "포트 65432를 리스닝하는 프로세스가 누구?"
```

#### **2단계: 소켓으로 데이터 전달 (실제 통신 단계)**
```
커널 → "포트 65432는 server.py 프로세스가 사용 중" → 해당 소켓으로 데이터 전달
```

### 📊 포트 vs 소켓 역할 비교

| 단계 | 포트의 역할 | 소켓의 역할 |
|------|-------------|-------------|
| **패킷 도착** | ✅ "어떤 프로세스에게?" 식별 | ❌ 아직 관여 안함 |
| **프로세스 찾기** | ✅ 커널이 포트 테이블 조회 | ❌ 아직 관여 안함 |
| **데이터 전달** | ❌ 역할 끝남 | ✅ 실제 데이터 송수신 |
| **응답 전송** | ❌ 관여 안함 | ✅ 소켓을 통해 응답 |

### 🔄 구체적인 데이터 흐름 예시

#### **클라이언트 → 서버 방향:**
```
1. 클라이언트: socket.sendall(b"Hello")
   ↓
2. TCP 패킷 생성: [TCP Header: dst_port=65432][Hello]
   ↓
3. 서버 커널: "포트 65432를 사용하는 프로세스는 server.py"
   ↓
4. 커널: server.py의 소켓 버퍼에 "Hello" 저장
   ↓
5. 서버: conn.recv(1024)로 소켓에서 "Hello" 읽기
```

#### **서버 → 클라이언트 방향:**
```
1. 서버: conn.sendall(b"Echo: Hello")
   ↓
2. 소켓 → 커널 → TCP 패킷 생성
   ↓
3. 클라이언트 커널: 클라이언트 소켓으로 데이터 전달
   ↓
4. 클라이언트: s.recv(1024)로 응답 수신
```

### 🛠️ 실습 코드로 확인하기

#### **server.py에서의 과정:**
```python
# 1. 포트 바인딩 (커널에게 "포트 65432는 내가 사용한다" 등록)
s.bind((HOST, PORT))  # PORT = 65432

# 2. 리스닝 (커널에게 "이 포트로 오는 연결 요청을 받겠다" 선언)
s.listen()

# 3. 연결 수락 (실제 통신용 소켓 생성)
conn, addr = s.accept()  # conn이 실제 데이터 전송용 소켓!

# 4. 데이터 수신 (소켓을 통해)
data = conn.recv(1024)   # 포트가 아닌 소켓을 통해 데이터 받기
```

### 💡 중요한 포인트

#### **1. 포트는 "한 번만" 사용됨**
- 패킷이 도착했을 때 프로세스 식별용으로만 사용
- 데이터 전달 후에는 포트의 역할 끝

#### **2. 소켓은 "계속" 사용됨**
- 연결이 유지되는 동안 모든 데이터 송수신
- 실제 애플리케이션이 직접 사용하는 인터페이스

#### **3. 서버 소켓 vs 연결 소켓**
```python
# 서버 소켓 (포트 바인딩용)
server_socket = socket.socket(...)
server_socket.bind((HOST, PORT))  # 포트와 연결
server_socket.listen()

# 연결 소켓 (실제 통신용)
conn, addr = server_socket.accept()  # 새로운 소켓 생성!
data = conn.recv(1024)              # 실제 데이터는 이 소켓으로
```

### 🔍 실습으로 확인하는 방법

#### **실행 중인 서버의 포트 상태 확인:**
```bash
# 서버 실행
python server.py

# 다른 터미널에서 포트 상태 확인
netstat -an | grep :65432
# 결과: 0.0.0.0:65432 LISTEN (포트가 대기 중)

# 클라이언트 연결 후
python client.py
# 다시 확인하면 ESTABLISHED 상태의 연결 소켓 보임
```

#### **소켓 파일 디스크립터 확인:**
```python
# server.py에 추가해보기
print(f"서버 소켓 FD: {s.fileno()}")        # 예: 3
print(f"연결 소켓 FD: {conn.fileno()}")     # 예: 4 (다른 번호!)
```

### 🎯 비유로 이해하기

**아파트 우편 시스템에 비유하면:**
- **포트**: 아파트 동호수 (편지를 누구에게 전달할지 결정)
- **소켓**: 실제 우편함 (편지를 주고받는 통로)

**과정:**
1. 편지에 적힌 동호수(포트)를 보고 해당 집 찾기
2. 찾은 집의 우편함(소켓)에 편지 넣기
3. 거주자가 우편함에서 편지 꺼내기

### 📚 핵심 요약

1. **포트**: 네트워크 패킷을 올바른 프로세스에게 전달하기 위한 "주소" 역할
2. **역할 종료**: 패킷이 해당 프로세스에게 전달되면 포트의 역할은 끝
3. **소켓**: 실제 데이터 송수신이 이루어지는 "통신 통로"
4. **데이터 흐름**: 포트(라우팅) → 소켓(실제 통신)

**이러한 구조 덕분에:**
- 하나의 서버에서 여러 서비스를 동시에 실행 가능 (다른 포트 사용)
- 각 연결마다 독립적인 소켓으로 안전한 통신
- 효율적인 네트워크 자원 관리